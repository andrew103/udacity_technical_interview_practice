=============================== QUESTION_1 ====================================
I decided to employ the method of popping characters out of lists of each
string since it felt like one of the more straightforward solutions to this
problem. I based this off the concept that an anagram of a word is formed by
using the letters within the original word and doesn't necessarily need to
follow the order of the letters in the original word. Given this idea, I
figured that if I go through each string and pop out the matches till either
there's not a match or all the letters in the anagram list have been popped.
In doing this, I not only find if the string is an anagram, but I also account
for duplicates in letters based on the rule that each letter can only be used
once. With this configuration, the runtime is O(n*m) since you're looping through
one string within the loop of the other. The memory efficiency is also O(n*m)
since you're working within two lists of the string elements.

=============================== QUESTION_2 ====================================
I feel that the way in which I solved this problem is one of the more space
efficient methods available, although maybe not the most time efficient. It
felt easy and simple enough to go through the string once and find all the
palindromes in that one run. This way, the space efficiency is limited to O(n),
based on the number of palindromes in the string after searching. With a little
more work however, it could be reduced to O(1) space efficiency. The time
efficiency is O(a*n*m). "n" is representative of the length of the string and
the process of iterating through it. "m" represents looping through a section
of the string to extract a palindrome. "a" represents looping through the
palindromes found to find the longest. With some added work, this could also be
reduced to O(n*m) efficiency.

=============================== QUESTION_3 ====================================
I used the methods of popping edges from nodes to distinguish visited nodes
since it seemed like one of the more imaginable ways to accomplish the task.
Meaning, its a process that at least I can visualize in my head and given that
what's given is an undirected graph, you pretty much have to search through
every possible combination. Given this constraint, I believe that time
efficiency for this problem is O(n^m) where n represents each node and m
represents each edge attributed to it. The space efficiency for this program
would be O(n*m) since you have a loop within another loop in a couple cases.

=============================== QUESTION_4 ====================================


=============================== QUESTION_5 ====================================
